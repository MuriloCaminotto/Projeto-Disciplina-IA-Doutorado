# -*- coding: utf-8 -*-
"""ProcessamentoImagem.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19Hvuxn7HqC5xNqvO7UcvF4vS-Xh-JOFj
"""

import cv2
from google.colab.patches import cv2_imshow
import numpy as np
from google.colab import output
from time import sleep
#from skimage.feature import hog
from skimage import feature
from joblib import dump, load

MEDIAGLOBAL = 73.8515
STDGLOBAL   = 33.5265


def aplyFullTransform(img):
    equ = cv2.equalizeHist(img)
    
    #cria tabela vazia
    lookUpTable = np.empty((1,256), np.uint8)

    #Calculo dos fatores de padronizacao
    mi   = np.mean(equ)
    stdi = np.std(equ)

    A = stdi/STDGLOBAL
    B = mi - A*MEDIAGLOBAL
    
    #calcula os valores para a tabela de lookup
    for i in range(256):
        lookUpTable[0,i] = np.clip(A*i+B, 0, 255)

    #aplica a transformacao
    res = cv2.LUT(img,lookUpTable)

    return res

def check_colision(l1,r1,l2,r2):
  if l1[0] >= r2[0] or l2[0] >= r1[0]:
    return False
  
  if l1[1] >= r2[1] or l2[1] >= r1[1]:
    return False
  
  return True

def find_median_square(d):
  list_of_squares = []
  for key in d.keys():
    #Se existe alguma colisão
    if d[key]!=[]:
      #seleciona o que esta mais no meio
      topleftXs = [int(x[0]) for x in d[key]]
      if len(topleftXs)%2 == 0:
        topleftXs.remove(max(topleftXs))
      selected = topleftXs.index(int(np.median(topleftXs)))
      list_of_squares.append(d[key][selected])
  return list_of_squares

def achaFolha(path2img,path2clf,path2result,ori,cell,block,method='',tamanhos = [32,64,128,384]):
  imgname = path2img
  clf  = load(path2clf)
  img = cv2.imread(imgname)# Carrega a img
  imgResult = img.copy()
  img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
  maxh,maxl = img.shape# Pega o tamanho da img
  
  #Dicionario de colisões de quadrados
  D = {}
  for t in tamanhos:#Testa cada quadro
    altura = 0
    while altura + t < maxh:
      largura = 0
      while largura + t < maxl:

        pedaco = img[altura:altura+t,largura:largura+t]
        for m in method.split('-'):
          if m == 'full':
            pedaco = aplyFullTransform(pedaco)
          elif m == 'bin':
            pedaco,_ = cv2.threshold(pedaco,0,255,cv2.THRESH_BINARY+cv2.THRESH_OTSU)
          elif m == 'equ':
            pedaco = cv2.equalizeHist(pedaco)


        resized = cv2.resize(pedaco,(64,64))

        #fd = hog.compute(resized)
        fd = feature.hog(resized, orientations=ori, pixels_per_cell=(cell, cell),
            cells_per_block=(block, block), transform_sqrt=True, block_norm="L1",
            visualize=False)
        resp = clf.predict(fd.reshape(1, -1))

        if resp == 1:
          #Inicio fluxo detectar colisão
          if D != {}:
            colidiu = False
            for q in D.keys():
              
              l1 = (int(q.split(',')[0]),int(q.split(',')[1]))
              r1 = (int(q.split(',')[2]),int(q.split(',')[3]))
              l2 = (largura,altura) 
              r2 = (largura+t,altura+t)
              #Se houve colisão
              if check_colision(l1,r1,l2,r2):
                #Adiciona o quadrado na lista de colisões
                D[q].append([largura,altura,largura+t,altura+t])
                colidiu = True
                break
            #Se n colidiu com nenhum
            if not colidiu:
              #Adiciona nova chave
              D[','.join([str(largura),str(altura),str(largura+t),str(altura+t)])] = [[largura,altura,largura+t,altura+t]]  
          else:
            D[','.join([str(largura),str(altura),str(largura+t),str(altura+t)])] = [[largura,altura,largura+t,altura+t]]

        largura+= int(t*0.1)

      altura+=int(t*0.1)
  list_of_Squares = find_median_square(D)
  if list_of_Squares != []:
    for s in list_of_Squares:
      imgResult = cv2.rectangle(imgResult,(s[0],s[1]),(s[2],s[3]),[0,0,255],1)  
  cv2_imshow(imgResult)
  cv2.imwrite(path2result+imgname.split('/')[-1].split('.')[0]+'resultado.jpg',imgResult)